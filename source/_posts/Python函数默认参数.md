---
title: Python函数默认参数
date: 2017-11-09 10:30:11
tags:
- Python
---

之前面试总会被问到这个问题，不过也只知道意思不是很了解内部原理  
今天来详细的总结一下
# Python变量
首先还是要理解一下python中变量的概念  
变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念  
Python是一种动态语言 变量并没有固定类型
Python中万物皆为对象 变量类似于C的指针  储存对象的地址
```python
a = 1
```
实际是把1所在地址赋给a
```shell
>>> id(1)
1666408672
>>> a = 1
>>> id(a)
1666408672
```
可以看到 1 和 a 的地址是一样的

```python
a = "hello"
```
```shell
>>> id("hello")
2087305568016
>>> a = "hello"
>>> id(a)
2087305568016
```

同理，把"hello"赋值给a之后 a 和 "hello" 的地址相同了

这里有个问题
```shell
>>> a = 1
>>> b = a
>>> a
1
>>> b
1
>>> a = 2
>>> a
2
>>> b
1
```

为什么 b 还是1呢  因为b = a是把 a 的值赋给 b 也就是把1赋给b  
a = 2把 a 指向2的地址  b 的还是指向1的地址
执行的过程中  
```shell
>>> id(1)
1666408672
>>> a = 1
>>> id(a)
1666408672
>>> b = a
>>> id(b)
1666408672
>>> a = 2
>>> id(a)
1666408704
>>> b
1
>>> id(b)
1666408672
```

# Python可变对象和不可变对象
可变对象就是指创建之后可以进行改变的  
指的是变量对应内存的值可以被改变  
不可变对象是不能改变的  
变量对应内存的值不会被改变  
我们来看个例子
```shell
>>> a = a +"1"
>>> id (a)
2087305572680
>>> id("hello")
2087305568016
```
还是刚才的 a 里面存的是"hello",我想在后面加上一个"1"  
a的地址发生了改变,"hello"的地址没有变化  
实际上是开了一片新的地址 储存了"hello"+"1"的结果  
然后让a指向这个地址

可变对象比如list
```shell
>>> l = []
>>> id(l)
2400009794120
>>> l.append(1)
>>> l
[1]
>>> id(l)
2400009794120
```
我们创建了一个list l ,向l中添加了一个元素1  
l发生了改变  但是他的地址没有变化

Python中可变对象有list dirt  
Python中不可变对象有int float bool str tuple
# Python函数默认参数
简单介绍下Python的函数
```python
def fun(n):
  return n * n
```
一个简单的返回一个数的平方  
在python中函数也是一个对象  可以复制给变量
```shell
>>> f = fun
>>> f(1)
1
>>> f(2)
4
```
Python中函数可以设置默认参数
```python
def fun(n=2):
  return n*n

fun()      4
fun(1)     1
fun(3)     9
```

好了  终于到了这里

这是一个之前面试总遇到的问题
```python
def fun(i,l=[]):
  l.append(i)
  return l
fun(1)
fun(4,[1,2,3])
fun(2)
```
问下面三条函数的执行结果   
在理论上我们想要的是
```shell
[1]
[1,2,3,4]
[2]
```
而实际上我们得到的结果是
```shell
[1]
[1,2,3,4]
[1,2]
```
为什么会这样呢

python中函数也是对象 每个函数只会初始化一次  
l在第一次调用的时候在系统中初始化了一个空的list  
当我们没有传入参数的时候 l 就指向这个空的list
第一次调用结束后这个list变为了[1]  
第二次我们传入了一个list l 就指向了我们传入的list
第三次我们没有传入list l 指向一开始传入的list并且这个list第一次已经添加了一个元素1 继续进行添加 结果是[1,2]

那么怎样避免这种情况呢  
我们可以把l初始化None  
把list的初始化放在函数内部
```python
def fun(i,l=None):
  if l is None:
    l = []
  l.append(i)
  return l
```

# 总结
当我们函数默认参数使用可变参数的时候  
可变参数会被初始化为一个全局变量  通常我们应当避免这种情况  
不过有些时候也可以利用这种状况
```python
def fun(i,cache={}):
  if i < 2:
    return 1
  cache[i] = fun(i-1)+fun(i-2)
  return cache[i]
```
这样我们就实现了一个简单的带缓存的斐波那契数列
